From aaed7da47133318ef976357ba4a702f30b60fa07 Mon Sep 17 00:00:00 2001
From: Marcin Niestroj <m.niestroj@emb.dev>
Date: Mon, 12 Sep 2022 19:34:18 +0200
Subject: [PATCH] twister: DeviceHandler: add DeviceSerial helper class

Split low-level device serial handling from other code.

Signed-off-by: Marcin Niestroj <m.niestroj@emb.dev>
---
 scripts/pylib/twister/twisterlib/handlers.py | 200 +++++++++++--------
 1 file changed, 119 insertions(+), 81 deletions(-)

diff --git a/scripts/pylib/twister/twisterlib/handlers.py b/scripts/pylib/twister/twisterlib/handlers.py
index f0a79917d3..7d4209a2b3 100755
--- a/scripts/pylib/twister/twisterlib/handlers.py
+++ b/scripts/pylib/twister/twisterlib/handlers.py
@@ -312,26 +312,33 @@ class BinaryHandler(Handler):
         self._final_handle_actions(harness, handler_time)
 
 
-class DeviceHandler(Handler):
-
-    def __init__(self, instance, type_str):
-        """Constructor
-
-        @param instance Test Instance
-        """
-        super().__init__(instance, type_str)
-
-    def monitor_serial(self, ser, halt_fileno, harness):
+class DeviceSerial:
+    class SerialError(RuntimeError):
+        pass
+
+    def __init__(self, hardware, timeout):
+        self.hardware = hardware
+        self.timeout = timeout
+        self.serial = None
+        self.read_pipe = None
+        self.write_pipe = None
+        self.thread = None
+        self.pty_process = None
+
+    def monitor_serial(self, harness, log, coverage):
         if harness.is_pytest:
             harness.handle(None)
             return
 
-        log_out_fp = open(self.log, "wt")
+        ser = self.serial
+        halt_fileno = self.read_pipe
+
+        log_out_fp = open(log, "wt")
 
         ser_fileno = ser.fileno()
         readlist = [halt_fileno, ser_fileno]
 
-        if self.options.coverage:
+        if coverage:
             # Set capture_coverage to True to indicate that right after
             # test results we should get coverage data, otherwise we exit
             # from the test.
@@ -376,6 +383,91 @@ class DeviceHandler(Handler):
 
         log_out_fp.close()
 
+    @property
+    def device(self):
+        if self.hardware.serial_pty:
+            return self.hardware.serial_pty
+
+        return self.hardware.serial
+
+    def start(self, harness, log, coverage):
+        if self.hardware.serial_pty:
+            master, slave = pty.openpty()
+            try:
+                self.pty_process = subprocess.Popen(re.split(',| ', self.hardware.serial_pty),
+                                                    stdout=master, stdin=master, stderr=master)
+            except subprocess.CalledProcessError as error:
+                logger.error("Failed to run subprocess {}, error {}".format(self.hardware.serial_pty, error.output))
+                raise self.SerialError(error.output) from error
+
+            node = os.ttyname(slave)
+        else:
+            node = self.hardware.serial
+
+        logger.debug(f"Using serial device {node} @ {self.hardware.baud} baud")
+
+        try:
+            self.serial = serial.Serial(
+                node,
+                baudrate=self.hardware.baud,
+                parity=serial.PARITY_NONE,
+                stopbits=serial.STOPBITS_ONE,
+                bytesize=serial.EIGHTBITS,
+                timeout=self.timeout
+            )
+        except serial.SerialException as e:
+            logger.error("Serial device error: %s" % (str(e)))
+
+            if self.hardware.serial_pty and self.pty_process:
+                self.pty_process.terminate()
+                outs, errs = self.pty_process.communicate()
+                logger.debug("Process {} terminated outs: {} errs {}".format(self.hardware.serial_pty, outs, errs))
+
+            raise self.SerialError(str(e)) from e
+
+        self.serial.flush()
+
+        self.read_pipe, self.write_pipe = os.pipe()
+
+        self.thread = threading.Thread(target=self.monitor_serial, daemon=True, args=(harness, log, coverage))
+        self.thread.start()
+
+    def halt(self):
+        if not self.write_pipe:
+            return
+
+        os.write(self.write_pipe, b'x')  # halt the thread
+
+    def stop(self, timeout):
+        if not self.thread:
+            return
+
+        self.thread.join(timeout)
+
+        if self.thread.is_alive():
+            logger.debug("Timed out while monitoring serial output on {}".format(self.hardware.platform))
+
+        if self.serial.isOpen():
+            self.serial.close()
+
+        if self.hardware.serial_pty:
+            self.pty_process.terminate()
+            outs, errs = self.pty_process.communicate()
+            logger.debug("Process {} terminated outs: {} errs {}".format(self.hardware.serial_pty, outs, errs))
+
+        os.close(self.write_pipe)
+        os.close(self.read_pipe)
+
+
+class DeviceHandler(Handler):
+
+    def __init__(self, instance, type_str):
+        """Constructor
+
+        @param instance Test Instance
+        """
+        super().__init__(instance, type_str)
+
     def device_is_available(self, instance):
         device = instance.platform.name
         fixture = instance.testsuite.harness_config.get("fixture")
@@ -425,22 +517,8 @@ class DeviceHandler(Handler):
             hardware = self.device_is_available(self.instance)
 
         runner = hardware.runner or self.options.west_runner
-        serial_pty = hardware.serial_pty
 
-        ser_pty_process = None
-        if serial_pty:
-            master, slave = pty.openpty()
-            try:
-                ser_pty_process = subprocess.Popen(re.split(',| ', serial_pty), stdout=master, stdin=master, stderr=master)
-            except subprocess.CalledProcessError as error:
-                logger.error("Failed to run subprocess {}, error {}".format(serial_pty, error.output))
-                return
-
-            serial_device = os.ttyname(slave)
-        else:
-            serial_device = hardware.serial
-
-        logger.debug(f"Using serial device {serial_device} @ {hardware.baud} baud")
+        serial_device = DeviceSerial(hardware, self.timeout)
 
         if (self.options.west_flash is not None) or runner:
             command = ["west", "flash", "--skip-rebuild", "-d", self.build_dir]
@@ -501,45 +579,22 @@ class DeviceHandler(Handler):
         if pre_script:
             self.run_custom_script(pre_script, 30)
 
+        harness_name = self.instance.testsuite.harness.capitalize()
+        harness_import = HarnessImporter(harness_name)
+        harness = harness_import.instance
+        harness.configure(self.instance)
+
         try:
-            ser = serial.Serial(
-                serial_device,
-                baudrate=hardware.baud,
-                parity=serial.PARITY_NONE,
-                stopbits=serial.STOPBITS_ONE,
-                bytesize=serial.EIGHTBITS,
-                timeout=self.timeout
-            )
-        except serial.SerialException as e:
+            serial_device.start(harness, self.log, self.options.coverage)
+        except DeviceSerial.SerialError:
+            self.instance.add_missing_case_status("blocked", "Serial Device Error")
             self.instance.status = "failed"
             self.instance.reason = "Serial Device Error"
-            logger.error("Serial device error: %s" % (str(e)))
-
-            self.instance.add_missing_case_status("blocked", "Serial Device Error")
-            if serial_pty and ser_pty_process:
-                ser_pty_process.terminate()
-                outs, errs = ser_pty_process.communicate()
-                logger.debug("Process {} terminated outs: {} errs {}".format(serial_pty, outs, errs))
-
-            if serial_pty:
-                self.make_device_available(serial_pty)
-            else:
-                self.make_device_available(serial_device)
+            self.make_device_available(serial_device.device)
             return
 
-        ser.flush()
-
-        harness_name = self.instance.testsuite.harness.capitalize()
-        harness_import = HarnessImporter(harness_name)
-        harness = harness_import.instance
-        harness.configure(self.instance)
-        read_pipe, write_pipe = os.pipe()
         start_time = time.time()
 
-        t = threading.Thread(target=self.monitor_serial, daemon=True,
-                             args=(ser, read_pipe, harness))
-        t.start()
-
         d_log = "{}/device.log".format(self.instance.build_dir)
         logger.debug('Flash command: %s', command)
         flash_error = False
@@ -557,7 +612,7 @@ class DeviceHandler(Handler):
                         flash_error = True
                         with open(d_log, "w") as dlog_fp:
                             dlog_fp.write(stderr.decode())
-                        os.write(write_pipe, b'x')  # halt the thread
+                        serial_device.halt()
                 except subprocess.TimeoutExpired:
                     logger.warning("Flash operation timed out.")
                     proc.kill()
@@ -570,7 +625,7 @@ class DeviceHandler(Handler):
                 dlog_fp.write(stderr.decode())
 
         except subprocess.CalledProcessError:
-            os.write(write_pipe, b'x')  # halt the thread
+            serial_device.halt()
             self.instance.status = "error"
             self.instance.reason = "Device issue (Flash error)"
             flash_error = True
@@ -579,28 +634,14 @@ class DeviceHandler(Handler):
             self.run_custom_script(post_flash_script, 30)
 
         if not flash_error:
-            t.join(self.timeout)
+            serial_device.stop(self.timeout)
         else:
             # When the flash error is due exceptions,
             # twister tell the monitor serial thread
             # to close the serial. But it is necessary
             # for this thread being run first and close
             # have the change to close the serial.
-            t.join(0.1)
-
-        if t.is_alive():
-            logger.debug("Timed out while monitoring serial output on {}".format(self.instance.platform.name))
-
-        if ser.isOpen():
-            ser.close()
-
-        if serial_pty:
-            ser_pty_process.terminate()
-            outs, errs = ser_pty_process.communicate()
-            logger.debug("Process {} terminated outs: {} errs {}".format(serial_pty, outs, errs))
-
-        os.close(write_pipe)
-        os.close(read_pipe)
+            serial_device.stop(0.1)
 
         handler_time = time.time() - start_time
 
@@ -625,10 +666,7 @@ class DeviceHandler(Handler):
         if post_script:
             self.run_custom_script(post_script, 30)
 
-        if serial_pty:
-            self.make_device_available(serial_pty)
-        else:
-            self.make_device_available(serial_device)
+        self.make_device_available(serial_device.device)
 
 class QEMUHandler(Handler):
     """Spawns a thread to monitor QEMU output from pipes
-- 
2.37.3

